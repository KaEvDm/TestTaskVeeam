# Задача
Написать консольную программу на C#, предназначенную для поблочного сжатия и расжатия файлов 
с помощью System.IO.Compression.GzipStream. 

Для компрессии исходный файл делится на блоки одинакового размера, например, в 1 мегабайт. 
Каждый блок компрессится и записывается в выходной файл независимо от остальных блоков.

Программа должна эффективно распараллеливать и синхронизировать обработку блоков  в многопроцессорной 
среде и уметь обрабатывать файлы, размер которых превышает объем доступной оперативной памяти. 
В случае исключительных ситуаций необходимо проинформировать пользователя понятным сообщением, 
позволяющим пользователю исправить возникшую проблему, в частности если проблемы связаны 
с ограничениями операционной системы.

При работе с потоками допускается использовать только стандартные классы и библиотеки из .Net 3.5 
(исключая ThreadPool, BackgroundWorker, TPL). Ожидается реализация с использованием Thread-ов.
Код программы должен соответствовать принципам ООП и ООД (читаемость, разбиение на классы и т.д.). 
Параметры программы, имена исходного и результирующего файлов должны задаваться в командной строке 
следующим образом:

GZipTest.exe compress/decompress [имя исходного файла] [имя результирующего файла]

Исходники необходимо прислать вместе с проектом Visual Studio.

# Решение

## Архитектура системы

![UML](/Images/UML.png)

## Общий алгоритм работы программы

![Алгоритм](/Images/CommonAlgorithm.jpg)

Краткое описание алгоритма:
1. На основе аргументов командной строки, а именно режима работы программы и путей до исходного и итогового файлов, приложение создаёт обработчик. Обработчик состоит из трёх логических кострукций: "модуль чтения", "модуль обработки" и "модуль записи". Добавляя различные модули в программу, можно расширять её функциональность.
2. Обработчик передаётся классу отвечающему за многопоточность.
3. Класс отвечающий за многопоточность создаёт поток "чтения" в котором будет выполнятся "модуль чтения" обработчика.
Стандартный "модуль чтения" считывает данные из исходного файла и создаёт новые блоки (каждому блоку, при создании присваивается порядковый номер).
4. Считаные блоки поступают в очередь на обработку.
5. Далее оздаётся N потоков "обработки", соответсвенно выполняющих "модуль обработки" (где N - удвоенное количество ядер процессора, минус два (основной поток и поток чтения)).
6. "Модуль обработки" запущенный в каждом потоке обработки забирает блоки из очереди на обработку, и обрабатывает соответствующим образом.
7. Обработанный блок поступает в очередь на запись (так как блоки могут быть обработаны с разной скоростью, очередь реализует запись блоков строго по порядку).
8. В основном потоке запускается "модуль записи", забирающий блоки из очереди на запись, и записывающий их в итоговый файл.
9. По завершению потока записи программа уведомляет пользователя об успешном результате, закрывает все потоки и завершает работу.

## Compress

Поток чтения считывает данные по одному мегабайту и создаёт блоки, которые затем поступают в очередь на обработку.
Потоки обработки сжимают блоки, добавляя информацию о новом размере блока перед заголовком GZip.

![GZip](/Images/GZipStructure.jpg)
Более подробно о структуре файлов сжатых при помощи GZip вы можете прочитать на сайте http://www.zlib.org/rfc-gzip.html

Инофрмация о размере сжатого блока записывается потому, что все блоки записываются подряд в один файл, и при поблочном разжатии такого файла, возникает подребность знать сколько байт считывать, чтобы получить цельный блок.

На выходе получаются сжатые блоки, которые поступают в очередь на запись.

## Decompress

Поток чтения считывает данные размером, который указан перед каждым блоком (см. выше) и создаёт блоки, которые затем поступают в очередь на обработку.
Потоки обработки разжимают блоки и отправляют в очередь на запись.
