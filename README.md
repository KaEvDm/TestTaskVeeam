# Задача
Написать консольную программу на C#, предназначенную для поблочного сжатия и расжатия файлов 
с помощью System.IO.Compression.GzipStream. 

Для компрессии исходный файл делится на блоки одинакового размера, например, в 1 мегабайт. 
Каждый блок компрессится и записывается в выходной файл независимо от остальных блоков.

Программа должна эффективно распараллеливать и синхронизировать обработку блоков  в многопроцессорной 
среде и уметь обрабатывать файлы, размер которых превышает объем доступной оперативной памяти. 
В случае исключительных ситуаций необходимо проинформировать пользователя понятным сообщением, 
позволяющим пользователю исправить возникшую проблему, в частности если проблемы связаны 
с ограничениями операционной системы.

При работе с потоками допускается использовать только стандартные классы и библиотеки из .Net 3.5 
(исключая ThreadPool, BackgroundWorker, TPL). Ожидается реализация с использованием Thread-ов.
Код программы должен соответствовать принципам ООП и ООД (читаемость, разбиение на классы и т.д.). 
Параметры программы, имена исходного и результирующего файлов должны задаваться в командной строке 
следующим образом:

GZipTest.exe compress/decompress [имя исходного файла] [имя результирующего файла]

Исходники необходимо прислать вместе с проектом Visual Studio.

# Решение

## Архитектура системы

![UML](/Images/UML.png)

## Общий алгоритм работы программы

![Алгоритм](/Images/CommonAlgorithm.jpg)

Краткое описание алгоритма:
1. Создаётся поток "чтения", считывающий данные из исходного файла и создающий новые блоки (каждому блоку, при создании присваивается порядковый номер).
2. Блок поступает в очередь ожидания на обработку.
3. Создаётся N потоков "обработки" (где N - удвоенное количество ядер процессора, минус два (основной поток и поток чтения)).
4. Каждый поток обработки забирает блоки из очереди ожидания на обработку, и обрабатывает соответствующим образом (тип обработки устанавливается на основе режима работы программы(compress/decompress)).
5. Обработанный блок поступает в очередь ожидания на запись (так как блоки могут быть обработаны с разной скоростью, очередь реализует запись блоков строго по порядку).
6. В основном потоке запускается метод "записи", забирающий блоки из очереди ожидания на запись, и записывающий их в получившийся файл.
7. По завершению потока записи программа уведомляет пользователя об успешном результате, закрывает все потоки и завершает работу.

После того, как весь файл считан и поток четния уже не нужен, он переключается на обрабтку. Это позволяет получить небольшой прирост скорости рабоыт программы.

![Конец чтения](/Images/EndReading.jpg)

После того, как все блоки обработаны, остаётся записать в файл оставшиеся блоки из очереди на запись.

![Конец обработки](/Images/EndProcessing.jpg)

## Compress

![Compress](/Images/Compress.jpg)

Поток чтения считывает данные по одному мегабайту и создаёт блоки, которые затем поступают в очередь на обработку.
Потоки обработки сжимают блоки, добавляя информацию о новом размере блока перед заголовком GZip.

![GZip](/Images/GZipStructure.jpg)
Более подробно о структуре файлов сжатых при помощи GZip вы можете прочитать на сайте http://www.zlib.org/rfc-gzip.html

Инофрмация о размере сжатого блока записывается потому, что все блоки записываются подряд в один файл, и при поблочном разжатии такого файла, возникает подребность знать сколько байт считывать, чтобы получить цельный блок.

На выходе получаются сжатые блоки, которые поступают в очередь на запись.

## Decompress

![Decompress](/Images/Decompress.jpg)

Поток чтения считывает данные размером, который указан перед каждым блоком (см. выше) и создаёт блоки, которые затем поступают в очередь на обработку.
Потоки обработки разжимают блоки и отправляют в очередь на запись.
